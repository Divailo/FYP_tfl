PROGRAM Any_Plan; /*  */

VAP_FREQUENCY 1;

CONST
            StartingStage = 1,
 CycleLength = 72.0 ,
            Log = 1,
            True = 1,
            False = 0,
 RedAmberFix = 0 ;

/* ARRAYS */
ARRAY
 Plan[ 10, 9 ] = [ [09, 3, 0, 0, 0, 0, 0, 0, 0] , [24, 1, 0, 0, 0, 0, 0, 0, 0] , [56, 2, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0] ],
 DDStages[ 8, 4 ] = [ [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] , [-1, 0, 0, 0] ],
 PhasesInStage[ 8, 26 ] = [ [1, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [2, 3, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [4, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] , [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ],
 PhaseData[ 26, 2 ] = [ [7, 1] , [7, 1] , [7, 1] , [7, 1] , [5, 2] , [5, 2] , [6, 2] , [5, 2] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] , [-1, 0] ];


/* SUBROUTINES */

SUBROUTINE NextStageDD;  /* NextStageDD.vv */
D01S00Z002: Index2 := 1;
D01S02Z002: IF DDStages[Index2, 1] = -1 THEN
D01S03Z002:   IsStageDD := false
            ELSE
D01S02Z003:   IF DDStages[Index2, 1] = NextStage THEN
D01S03Z003:     IsStageDD := true;
D01S05Z003:     DetTimer := DDStages[Index2, 3]
              ELSE
D01S02Z004:     Index2 := Index2 + 1;
                GOTO D01S02Z002
              END
            END
D01PROG_ENDE: .
/*----------------------------------------------------------------------------*/

SUBROUTINE FindNextStage;  /* FindNextStage.vv */
D02S01Z001: index_k := 1;
D02S01Z003: index_k := index_k + 1;
D02S01Z004: IF index_k > 9 THEN
D02S03Z004:   index_k := 1;
D02S05Z004:   IF NOT (index_k > 8) THEN
D02S06Z004:     IF Plan[ BitPatternIndex, index_k+1 ] THEN
D02S07Z004:       NextStage := Plan[ BitPatternIndex, index_k+1 ];
D02S08Z004:       GOSUB NextStageDD;
D02S09Z004:       IF IsStageDD THEN
D02S10Z004:         IF DDStages[Index2, 4] = 0 THEN
D02S11Z004:           IF NOT (DetTimer > 0) THEN
D02S13Z004:             IF NOT (Detection( DDStages[Index2, 2] )) THEN
D02S13Z007:               index_k := index_k + 1;
                          GOTO D02S05Z004
                        END
                      ELSE
D02S12Z005:             IF NOT (Occupancy( DDStages[Index2, 2] ) > DetTimer) THEN
                          GOTO D02S13Z007
                        END
                      END
                    ELSE
D02S10Z006:           IF valTest > DDStages[Index2, 2] THEN
                        GOTO D02S13Z007
                      END
                    END
                  END
                ELSE
D02S06Z009:       NextStage := CurrentStage
                END
              ELSE
                GOTO D02S06Z009
              END
            ELSE
D02S01Z006:   IF NOT Plan[ BitPatternIndex, index_k ] THEN
                GOTO D02S03Z004
              ELSE
D02S01Z009:     IF Plan[ BitPatternIndex, index_k ] = CurrentStage THEN
                  GOTO D02S06Z009
                ELSE
                  GOTO D02S01Z003
                END
              END
            END
D02PROG_ENDE: .
/*----------------------------------------------------------------------------*/

SUBROUTINE RunTrace;  /* RunTrace.vv */
D03S01Z002: IF NOT Log THEN
              GOTO D03PROG_ENDE
            ELSE
D03S01Z003:   IF NextStage = 1 THEN
D03S02Z003:     Stage_1_Calls := Stage_1_Calls + 1;
D03S04Z006:     Trace( variable( Stage_1_calls ) ); Trace( variable( Stage_2_calls ) ); Trace( variable( Stage_3_calls ) ); Trace( variable( Stage_4_calls ) ); Trace( variable( Stage_5_calls ) ); Trace( variable( Stage_6_calls ) ); Trace( variable( Stage_7_calls ) ); Trace( variable( Stage_8_calls ) ); Trace( variable( Cycles ) );
                GOTO D03PROG_ENDE
              ELSE
D03S01Z004:     IF NextStage = 2 THEN
D03S02Z004:       Stage_2_Calls := Stage_2_Calls + 1;
                  GOTO D03S04Z006
                ELSE
D03S01Z005:       IF NextStage = 3 THEN
D03S02Z005:         Stage_3_Calls := Stage_3_Calls + 1;
                    GOTO D03S04Z006
                  END
                END
              END
            END;
D03S01Z006: IF NextStage = 4 THEN
D03S02Z006:   Stage_4_Calls := Stage_4_Calls + 1;
              GOTO D03S04Z006
            ELSE
D03S01Z007:   IF NextStage = 5 THEN
D03S02Z007:     Stage_5_Calls := Stage_5_Calls + 1;
                GOTO D03S04Z006
              ELSE
D03S01Z008:     IF NextStage = 6 THEN
D03S02Z008:       Stage_6_Calls := Stage_6_Calls + 1;
                  GOTO D03S04Z006
                ELSE
D03S01Z009:       IF NextStage = 7 THEN
D03S02Z009:         Stage_7_Calls := Stage_7_Calls + 1;
                    GOTO D03S04Z006
                  ELSE
D03S01Z010:         IF NextStage = 8 THEN
D03S02Z010:           Stage_8_Calls := Stage_8_Calls + 1;
                      GOTO D03S04Z006
                    END
                  END
                END
              END
            END
D03PROG_ENDE: .
/*----------------------------------------------------------------------------*/

SUBROUTINE PhaseMinsComplete;  /* PhaseMinsComplete.vv */
D04S02Z002: index_sg := 1;
D04S02Z004: index_ic := 1;
D04S02Z006: IF index_sg = PhasesInStage[ CurrentStage, index_ic ] THEN
D04S03Z006:   index_in := 1;
D04S04Z006:   IF (PhaseData[ index_sg, 2 ] = 1) AND RedAmberFix THEN
D04S05Z006:     RA := 2;
D04S08Z006:     IF index_sg = PhasesInStage[ NextStage, index_in ] THEN
D04S03Z011:       index_sg := index_sg + 1;
D04S03Z012:       IF index_sg > 26 THEN
D04S04Z012:         PhaseMinsDone := 1
                  ELSE
                    GOTO D04S02Z004
                  END
                ELSE
D04S08Z007:       index_in := index_in + 1;
D04S08Z008:       IF index_in > 26 THEN
D04S10Z008:         IF T_green( index_sg ) < PhaseData[ index_sg, 1 ] - RA THEN
D04S11Z008:           PhaseMinsDone := 0
                    ELSE
                      GOTO D04S03Z011
                    END
                  ELSE
                    GOTO D04S08Z006
                  END
                END
              ELSE
D04S04Z007:     RA := 0;
                GOTO D04S08Z006
              END
            ELSE
D04S02Z007:   index_ic := index_ic + 1;
D04S02Z008:   IF Index_ic > 26 THEN
                GOTO D04S03Z011
              ELSE
                GOTO D04S02Z006
              END
            END
D04PROG_ENDE: .
/*----------------------------------------------------------------------------*/

SUBROUTINE TimeForStageChange;  /* TimeForStageChange.vv */
D05S01Z002: Index := 1;
D05S03Z002: IF NOT (Plan[Index,1] = -1) THEN
D05S03Z003:   IF Plan[Index,1] = CycleTime THEN
D05S04Z003:     IsTimeForStageChange := true;
D05S05Z003:     BitPatternIndex := Index
              ELSE
D05S03Z004:     Index := Index + 1;
                GOTO D05S03Z002
              END
            END
D05PROG_ENDE: .
/*----------------------------------------------------------------------------*/

SUBROUTINE ExecuteUTC;  /* ExecuteUTC.vv */
D06S00Z001: IF Any_interstage_active THEN
D06S01Z001:   CurrentStageTime := 0;
              GOTO D06PROG_ENDE
            END;
D06S00Z004: IF IsTimeForStageChange THEN
D06S01Z004:   GOSUB FindNextStage;
D06S02Z004:   IF NextStage <> CurrentStage THEN
D06S03Z004:     GOSUB PhaseMinsComplete;
D06S04Z004:     IF NOT PhaseMinsDone THEN
D06S07Z005:       CurrentStageTime := CurrentStageTime + 1
                ELSE
D06S04Z005:       Interstage(CurrentStage, NextStage); IsTimeForStageChange := false; CurrentStage := NextStage;
D06S05Z005:       GOSUB RunTrace;
                  GOTO D06S07Z005
                END
              ELSE
                GOTO D06S07Z005
              END
            ELSE
              GOTO D06S07Z005
            END
D06PROG_ENDE: .
/*----------------------------------------------------------------------------*/

/* PARAMETERS DEPENDENT ON SCJ-PROGRAM */

/* EXPRESSIONS */

/* MAIN PROGRAM */

S01Z001:    IF NOT Init THEN
S03Z001:      CurrentStage := StartingStage;
S05Z001:      CurrentStageTime := 0;
S06Z001:      Cycles := 1;
S07Z001:      Init := 1
            END;
S01Z003:    simTime := simTime + 1;
S01Z004:    IF Velocity( 8888 ) THEN
S02Z004:      speed := Velocity( 8888 )
            END;
S01Z006:    CycleTime := CycleTime + 1;
S01Z007:    IF CycleTime > CycleLength THEN
S02Z007:      CycleTime := 1; Cycles := Cycles + 1
            END;
S03Z009:    rN := Sqrt( simTime ) + speed;
S06Z009:    IF counter > rN THEN
S07Z009:      valTest := ( rN - counter + 1 ) * 100;
S07Z010:      counter := 0
            ELSE
S06Z010:      counter := counter + 1;
              GOTO S06Z009
            END;
S01Z013:    Set_cycle_second( CycleTime );
S03Z013:    GOSUB TimeForStageChange;
S04Z013:    GOSUB ExecuteUTC
PROG_ENDE:    .
/*----------------------------------------------------------------------------*/